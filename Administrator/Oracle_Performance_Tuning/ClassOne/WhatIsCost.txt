-------------------------------------------------------------------------------

-- File Name     : WhatISCost.txt

-- Author        : Alex(Zhouyang Zheng)

-- Corporation	 : Cloud Creek Systems, Inc.

-- Call Syntax   : Notes

-- Requirements  : Access Privileges

-- Last Modified : 04/17/2017

-- Description   : Cost concepts

-------------------------------------------------------------------------------

1. Cost generated by CBO sometimes doesn't reflect the real resource consumption

2. optimizer options:

	all rows: optimizer会选择一个最快的exec plan去缩短整个query的执行时间，主要适用于dw
	
	first_rows_N: 通过第一个join order估算出总的data set，然后通过n再估算出要fetch data的
					比例。optimizer会选择一个最优的exec plan去减少系统资源的使用。
					
	first_rows:   deprecated, but exists for backward compatibility. 这个option会尽量让
					optimizer使用index,有时可能并不合适。
					
3. dynamic sampling/statistics

	it is an auxiliary features. The default parameter is optimizer_dynamic_sampling and 
	value is 2(use this features when table is missing statistics)
	
	This features is useful when missing statistics, stale statistics, insufficient statistics,
	parallel execution, sql plan directives conditions are meet. 
	
	stale statistics means 10% rows of tables are changed since last statistics gathering.
	
4. Cost model

	cost model from oracle is not perfect. It still evolves now. So you can't change to 
	other exec plan only refers to cost!
	
	cost = (
		#SRDs * sreadtim + 
		#MRDs * mreadtim +
		#CPUCycles / cpuspeed
	) / sreadtim;
	
	#SRDs number of single block reads
	#MRDs number of multi block reads
	#CPUcycles number of CPU Cycles
	
	If the event is merge join / hash join / sorting, using direct path
	writes and reads
	
	depends on which kind of bound for the database, using different cost model
	
CPU-bound database:
	
	alter system set "_optimizer_cost_model"=cpu scope=both;
	
	or using hints:
	
	select /*+ no_cpu_costing */ col1 from mytab;
	
IO-bound database:

	alter system set "_optimizer_cost_model"=io scope=both;
	
5. Transformation and Costing

	Oracle could transfer SQL into other equivalent statement
	
	e.g you join a view and table
	
	exec plan 1: instantiated view and join table into result sets
	
	exec plan 2: open up the view, join two tables firstly, then 
	execute sorting and selection operation.
	
	if join t1,t2 is expensive, choose plan 1
	
	otherwise, choose plan 2
	
parameter :

		_complex_view_merging:
				detemines whether view is opened up.
				
		merge()/no_merge() hint determins the execution plan
		
		query_rewrite
				a feature of materialized view
				
		10053 trace file
				contain optimizer's cost calculations
